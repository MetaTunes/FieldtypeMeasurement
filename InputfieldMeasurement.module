<?php namespace ProcessWire;
use MetaTunes\MeasurementClasses\{BaseMeasurement, Measurement, Dimension};

/**
 * ProcessWire Button Inputfield
 * expected by FieldtypeMeasurement
 *
 * @author Mark Evens
 * @license Licensed under GNU/GPL v3
 * @link https://processwire.com/talk/topic/26241-fieldtypemeasurement/
 * 
 * ProcessWire 2.x, 3.x 
 * Copyright (C) 2016 by Ryan Cramer 
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 * 
 * http://processwire.com
 * @version 0.0.7
 * @since 0.0.6 new namespaces, refactoring and extended dimensions
 * @since 0.0.5 minor fixes and new Measurement methods
 * @since 0.0.4 allowed specific formats in config file, additional units, dimensional analysis supported
 * @since 0.0.3 bug fixes
 * @since 0.0.2 revised db schema to hold base unit value
 * @since 0.0.1 additional formatting options
 * @since 0.0.0 initial version
 *
 */

class InputfieldMeasurement extends Inputfield {

    public static function getModuleInfo() {
        return array(
            'title' => __('Inputfield Measurement', __FILE__),
            'summary' => __('Edit a measurement in specified units.', __FILE__),
            'version' => '0.0.7',
            'author' => 'Mark Evens',
            'requires' => array("FieldtypeMeasurement")
        );
    }

    protected $field;

    /**
     * Construct the Inputfield, setting defaults for all properties
     *
     */
    public function __construct() {
        parent::__construct();
        require_once(dirname(__FILE__) . '/Measurement.php');
    }

    /**
     * Set the current Field
     *
     * @param Field $field
     *
     */
    public function setField(Field $field) {
        $this->field = $field; 
    }

	/**
	 * Page object that houses this field.
	 */
	protected $page;
	public function setPage(Page $page)
	{
		$this->page = $page;
	}

    /**
     * Per the Module interface, init() is called when the system is ready for API usage
     *
     */
    public function init() {
		parent::init();
	}

	/**
	 * Return the completed output of this Inputfield, ready for insertion in an XHTML form
	 *
	 * @return string
	 *
	 * @throws WirePermissionException
	 */
    public function ___render() {
		$name = $this->attr('name');
		$field = $this->field;
		$page = $this->page;
//		bd($this->attr('value'), 'value in render 0');
		$value = $this->attr('value');
		if(!$value || !$value->quantity){
			$value = new Measurement($field->quantity);
			//bd($value, 'value');
		}

		//bd($value->get('quantity'), 'quantity');
		//bd($value->get('units'), 'units');
		//bd($value->get('unit'), 'unit');
//		bd($value->get('notes'), 'notes');
		$inputfields = new InputfieldFieldset();
		$numberOfCols = 2;
		if($field->show_update) $numberOfCols ++;
		$colWidth = 100 / $numberOfCols;
		$notes = $value->units->get('notes');
		$units = $value->units->definitions;


		// quantity
		if (!$field->hide_quantity) {
			$f = $this->modules->get("InputfieldMarkup");
			$f->label = $value->get('quantity') . ': ' . $this->_("Notes");
			$f->attr('name', "{$name}_Name");
			$out = ''; //"<h3>{$value->get('quantity')}</h3>";
			$f->collapsed = Inputfield::collapsedYes;
			$f->columnWidth = 100;

			$notes = ($notes) ? "<p>$notes</p>" : null;
			//bd($units, 'units');
			foreach($field->units as $unit) {
				//bd($units[$unit], 'units[unit]');
				$label = (isset($units[$unit]['alias']) && $units[$unit]['alias']) ? $units[$unit]['alias'] : $unit;
				$extraNotes = isset($units[$unit]['notes']) ? "<h4>{$label}</h4><p>{$units[$unit]['notes']}</p>" : null;
				$notes .= $extraNotes;
			}
			if ($notes) $out .= $notes;
			$f->attr('value', $out);
			$inputfields->add($f);
		}

        // magnitude
		//bd($value->get('magnitude'), 'magnitude 3');

        $f = $this->modules->get("InputfieldText");
        $f->label = $this->_("Magnitude");
        $f->attr('name', "{$name}_magnitude");
		$magnitude = (is_array($value->get('magnitude'))) ?  implode('|', $value->get('magnitude')) : $value->get('magnitude');
        $f->attr('value', $magnitude);
		$f->addClass('InputfieldMeasurement_magnitude');
//		$f->attr('placeholder', $value->get('unit'));
		$f->notes = __("Number or numbers separated by a 'pipe' | - e.g 2|3.4 (for combi units) ");
        $f->columnWidth = $colWidth;
        $inputfields->add($f);

		// unit
		$f = $this->modules->get("InputfieldSelect");
		$f->label = $this->_("Unit");
		$f->attr('name', "{$name}_unit");
		$f->attr('value', $value->get('unit'));
		//bd($value, 'value');
		foreach($field->units as $unit) {
			$shortLabel = (isset($units[$unit]) && isset($units[$unit]['shortLabel'])) ? $units[$unit]['shortLabel'] : null;
			$alias = (isset($units[$unit]) && isset($units[$unit]['alias'])) ? $units[$unit]['alias'] : $unit;
			if($shortLabel) $shortLabel = "($shortLabel)";
			$f->addOption($unit, "$alias $shortLabel");
			}
		$f->notes = $units[$value->get('unit')]->notes;
		$f->columnWidth = $colWidth;
		$inputfields->add($f);

		//update box
		if ($field->show_update) {
			$f = $this->modules->get('InputfieldCheckbox');
			$f->attr('name', "{$name}_update");
			$f->label = __('Convert magnitude (on save) if unit changed');
			$f->notes = __("If checked, the magnitude will automatically be converted on saving the page if the units have changed. It is reset to unchecked on each save/refresh.");
			$f->attr('checked', '');
			$f->columnWidth = $colWidth;
			$inputfields->append($f);
		}

        return $inputfields->render();
    }


    /**
     * This Inputfield is defined empty, if the magnitude field is not populated
     *
     * Used by the 'required' check to see if the field is populated.
     * Overwrites parent function Inputfield::isEmpty()
     *
     * @return bool
     *
     */
    public function isEmpty() {
        $value = $this->attr('value');
        if (is_object($value) && !strlen("{$value->magnitude}")) return true;
        return false; 
    }

    /**
     * Process the input from the given WireInputData (usually $input->get or $input->post), load and clean the value for use in this Inputfield.
     *
     * @param WireInputData $input
	 * @return $this
	 *
	 */
	public function ___processInput(WireInputData $input) {
		try {
			$name = $this->attr('name');
			$value = $this->attr('value');
			/* @var $value Measurement */
			$old = clone $value; // Don't want $old to change when $value is altered
			//bd($value, 'value at start of process input');
			// $value->targetSanitized = null;

			$input_names = array(
				'magnitude' => "{$name}_magnitude",
				'unit' => "{$name}_unit",
				'quantity' => "{$name}_quantity",
				'update' => "{$name}_update"
			);

			// loop inputs and set them if changed
			foreach($input_names as $key => $name) {
				//bd(['input' => $input->$name, 'value->key' => $value->get($key)], 'input name etc');
				if(isset($input->$name) && $value->get($key) != $input->$name) {
					if($key == 'magnitude') {
						$input->$name = trim($input->$name);

						/*
						 * Set the regex for the required pattern for the magnitude field
						 */
						//The relevant unit to use for formatting depends on whether we are updating...
						//bd($input[$input_names['update']], 'input names - update');
						if($input[$input_names['update']]) {
							$unit = $value->get('unit');
							$update = true;
						} else {
							$update = false;
							$unit = $input[$input_names['unit']];
						}
						// Now we know how many elements there should be to be separated by pipes
						$unitArray = explode('|', $unit);
						$unitCount = count($unitArray);
						// Set the pattern...
						$decimalPattern = "[+-]?([0-9]+\.?[0-9]*|\.[0-9]+)([eE][+-]?[0-9]+)?";  // matches scientific notation as well as decimal
						$re = '/^';
						for($i = 0; $i < $unitCount; $i++) {
							if($i > 0) $re .= '\|';
							$re .= $decimalPattern;
						}
						$re .= '$/';
						// ... and check the pattern
						$msg = $this->_("Change not made - magnitude not in correct format.");
						$msg .= "\n";
						$msg .= ($update) ? $this->_("When converting measurements, leave the magnitude in the correct format for the previous units.") :
							$this->_("Did you mean to convert the value? If so, tick the 'convert' box.");
						if(!preg_match($re, $input->$name)) throw new MeasurementException($msg);
						// If OK, carry on!

						if(!is_numeric($input->$name)) {
//							$magnitude = explode('|', $input->$name);
//							$magnitude = array_filter($magnitude, 'is_numeric');
							$magnitude = $this->sanitizer->magnitude($input->$name);
							$value->set($key, $magnitude);
						} else {
							$value->set($key, [$input->$name]);
						}
					} else {
						$value->set($key, $input->$name);
					}
					$this->trackChange('value');
					//bd($this->getChanges());
				}
			}

			$new = $value;
			//bd(['old' => $old, 'new' => $new], 'changes to field');
			$oldUnit = $old->get('unit');
			$newUnit = $new->get('unit');

//			bd($value->get('magnitude'), 'Magnitude');
//			bd(['old unit' => $oldUnit, 'new unit' => $newUnit], 'change of unit?');
//			bd($value->get('update'), 'update?');
			if($oldUnit and $newUnit and $oldUnit != $newUnit and $value->get('update') == 1) {
				//bd(['old unit' => $oldUnit, 'new unit' => $newUnit], 'change of unit');
				// Check consistency of units and magnitude
				//bd(['Mag' => count($value->get('magnitude')), 'Unit' => count((explode('|', $oldUnit)))], 'count compare old');
				if(count($value->get('magnitude')) != count((explode('|', $oldUnit)))) {
					// In theory, this should never happen as the input has already been checked
					throw new MeasurementException(sprintf($this->_('Magnitude (%1$s) not consistent with original unit (%2$s)'), $value->get('magnitude'), $oldUnit));
				}
				$value->set('unit', $oldUnit);
				$value->convertTo($newUnit);
			} else {
				//bd('No change');
				if($value->get('unit')) {
					// Check consistency of units and magnitude
					//bd(['Mag' => count($value->get('magnitude')), 'Unit' => count((explode('|', $newUnit)))], 'count compare new');
					if(count($value->get('magnitude')) != count((explode('|', $newUnit)))) {
						// In theory, this should never happen as the input has already been checked
						throw new MeasurementException(sprintf($this->_('Magnitude (%1$s) not consistent with chosen unit (%2$s)'), $value->get('magnitude'), $newUnit));
					}
				}
			}
			//bd($value, 'value at end of process_input');
			//bd($this, 'this at end of process_input');



		} catch(MeasurementException $e) {
			$this->error($e->getMessage());
		}
		return $this;
    }

	public function ___getConfigInputfields() {
		$inputfields = parent::___getConfigInputfields();
// No separate input settings at the moment - all in the details tab
		return $inputfields;
	}

	public function ___getConfigAllowContext($field) {
		$a = array(); // placeholder - no changes at present
		return array_merge(parent::___getConfigAllowContext($field), $a);
	}

}
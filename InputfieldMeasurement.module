<?php namespace ProcessWire;
use MetaTunes\MeasurementClasses\{BaseMeasurement, Measurement, Dimension, MeasurementException};

/**
 * ProcessWire Button Inputfield
 * expected by FieldtypeMeasurement
 *
 * @author Mark Evens
 * @license Licensed under GNU/GPL v3
 * @link https://processwire.com/talk/topic/26241-fieldtypemeasurement/
 * 
 * ProcessWire 2.x, 3.x 
 * Copyright (C) 2016 by Ryan Cramer 
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 * 
 * http://processwire.com
 * @version 0.0.7
 * @since 0.0.6 new namespaces, refactoring and extended dimensions
 * @since 0.0.5 minor fixes and new Measurement methods
 * @since 0.0.4 allowed specific formats in config file, additional units, dimensional analysis supported
 * @since 0.0.3 bug fixes
 * @since 0.0.2 revised db schema to hold base unit value
 * @since 0.0.1 additional formatting options
 * @since 0.0.0 initial version
 *
 */

class InputfieldMeasurement extends Inputfield {

    public static function getModuleInfo() {
        return array(
            'title' => __('Inputfield Measurement', __FILE__),
            'summary' => __('Edit a measurement in specified units.', __FILE__),
            'version' => '0.0.9',
            'author' => 'Mark Evens',
            'requires' => array("FieldtypeMeasurement")
        );
    }

    protected $field;

    /**
     * Construct the Inputfield, setting defaults for all properties
     *
     */
    public function __construct() {
        parent::__construct();
        require_once(dirname(__FILE__) . '/Measurement.php');
    }

    /**
     * Set the current Field
     *
     * @param Field $field
     *
     */
    public function setField(Field $field) {
        $this->field = $field; 
    }

	/**
	 * Page object that houses this field.
	 */
	protected $page;
	public function setPage(Page $page)
	{
		$this->page = $page;
	}

    /**
     * Per the Module interface, init() is called when the system is ready for API usage
     *
     */
    public function init() {
		$this->wire()->config->scripts->append("https://unpkg.com/htmx.org@1.7.0");
		parent::init();
	}

	/**
	 * Return the completed output of this Inputfield, ready for insertion in an XHTML form
	 *
	 * @return string
	 *
	 * @throws WirePermissionException
	 */
    public function ___render() {
		########### Get basic details ########################
		$name = $this->attr('name');
		$field = $this->field;
		$page = $this->page;

		//todo somehow if($page->$field->collapsed == 7) return $page->$field->render(); ?

		//bd($this->attr('value'), __METHOD__ . ': $value at line #' . __LINE__);
		$value = $this->attr('value');
		if(!$value || !$value->quantity){
			$value = new Measurement($field->quantity);

		}
		//bd($this->attr('value'), __METHOD__ . ': $value at line #' . __LINE__);

		##################### HTMX AJAX LISTENER #############################
		$input = $this->wire('input');
		$ajax = $this->wire('config')->ajax;
		// bd($ajax, __METHOD__ . ': $ajax at line #' . __LINE__);
		 //bd($input->get('fieldName'), __METHOD__ . ': $input->get(fieldName) at line #' . __LINE__);
		if ($ajax && str_starts_with($input->get('fieldName'), $this->attr('name'))) {
			//bd($ajax, __METHOD__ . ': $ajax at line #' . __LINE__);
			//bd($input->get('fieldName'), __METHOD__ . ': $input->get(fieldName) at line #' . __LINE__);
			//bd($input->get('id'), __METHOD__ . ': $input->get(id) at line #' . __LINE__);
			$name = $input->get('fieldName');
			$target = $input->get('target');
			$target = urldecode($target);
			$oldUnit =$value->get('unit');
			$unitName = "{$name}_unit";
			$newUnit = $input->$unitName;
			//bd($oldUnit, 'old unit');
			//bd($newUnit, 'new unit');
			$out = $this->htmxConvert($target, $value, $newUnit);
			echo $out;
			die();
		} else {
			// @debug
			//bd($ajax, __METHOD__ . ': $ajax - NO AJAX AND/OR WRONG INPUTFIELD - at line #' . __LINE__);
		}
		######################################## END OF HTMX LISTENER ##############################

		$inputfields = new InputfieldFieldset();

		$numberOfCols = ($field->hide_magnitude) ? 1 : 2;
		$colWidth = 100 / $numberOfCols;
		$notes = $value->units->get('notes');
		$units = $value->units->definitions;

		#################### Populate individual fields - quantity, magnitude & units ###################
		// quantity
		if (!$field->hide_quantity) {
			$f = $this->modules->get("InputfieldMarkup");
			$f->label = $value->get('quantity') . ': ' . $this->_("Notes");
			$f->attr('name', "{$name}_Name");
			$out = ''; //"<h3>{$value->get('quantity')}</h3>";
			$f->collapsed = Inputfield::collapsedYes;
			$f->columnWidth = 100;

			$notes = ($notes) ? "<p>$notes</p>" : null;
			//bd($units, 'units');
			foreach($field->units as $unit) {
				//bd($units[$unit], 'units[unit]');
				$label = (isset($units[$unit]['alias']) && $units[$unit]['alias']) ? $units[$unit]['alias'] : $unit;
				$extraNotes = isset($units[$unit]['notes']) ? "<h4>{$label}</h4><p>{$units[$unit]['notes']}</p>" : null;
				$notes .= $extraNotes;
			}
			if ($notes) $out .= $notes;
			$f->attr('value', $out);
			$inputfields->add($f);
		}

        // magnitude
		//bd($value->get('magnitude'), 'magnitude 3');
		if (!$field->hide_magnitude) {
			$combi = false;
			foreach($field->units as $unitOption) {
				if(strpos($unitOption, '|')) {
					$combi = true;
					break;
				}
			}
			if($combi) {
				$f = $this->modules->get("InputfieldText");
				$f->notes = __("Number or numbers separated by a 'pipe' | - e.g 2|3.4 (for combi units) ");
				$magnitude = (is_array($value->get('magnitude'))) ? implode('|', $value->get('magnitude')) : $value->get('magnitude');
			} else {
				$f = $this->modules->get("InputfieldText");
				$f->notes = __("Numeric");
				$f->precision = 6;
				$f->attr('type', "number");
				$f->attr('step', "any");
				if($value->get('magnitude')) {
					$magnitude = (is_array($value->get('magnitude'))) ? $value->get('magnitude')[0] : $value->get('magnitude');
				} else {
					$magnitude = null;
				}
			}
			$f->label = $this->_("Magnitude");
			$f->attr('name', "{$name}_magnitude");

			$f->attr('value', $magnitude);
			$f->addClass('InputfieldMeasurement_magnitude');
//		$f->attr('placeholder', $value->get('unit'));
			$f->columnWidth = $colWidth;
			$inputfields->add($f);
			$magnitudeHtml = $f->render();
		}

		// unit
		$f = $this->modules->get("InputfieldSelect");
		$f->label = $this->_("Unit");
		$f->attr('name', "{$name}_unit");
		$f->attr('value', $value->get('unit'));
		//bd($value, 'value');
		//bd($field->units, '$field->units');
		$first = true;
		foreach($field->units as $unit) {
			if(!$value->get('unit') && $field->set_default) {
				if($first) {
					$f->attr('value', $unit);
					$first = false;
				}
			}
			$shortLabel = (isset($units[$unit]) && isset($units[$unit]['shortLabel'])) ? $units[$unit]['shortLabel'] : null;
			$alias = (isset($units[$unit]) && isset($units[$unit]['alias'])) ? $units[$unit]['alias'] : $unit;
			if($shortLabel) $shortLabel = "($shortLabel)";
			$f->addOption($unit, "$alias $shortLabel");
			}
		if($value->unit) $f->notes = $units[$value->get('unit')]->notes;
		$f->columnWidth = $colWidth;
		if(!isset($field->enable_conversion)) $field->enable_conversion = 2; // Just in case, and covers the upgrade form old 'show_update' method
		if (!$field->hide_magnitude && $value->unit &&  $field->enable_conversion != 0) {   // 'Always', 'Ask' or unassigned conversion options
			#### add HTMX to do measurement conversion ####
			$targetHtml = (isset($magnitudeHtml)) ? $magnitudeHtml : '<input>';  // should always be set
			$targetHtml = urlencode($targetHtml);
			$adminEditURL = $this->wire('config')->urls->admin . "page/edit/";
			$adminEdit = "{$adminEditURL}?id={$this->page->id}&fieldName={$name}&target={$targetHtml}";
			//bd($adminEdit, __METHOD__ . ': $adminEdit at line #' . __LINE__);
			$target = "{$name}_magnitude";
			$source = "{$name}_unit";
			//bd($name, 'name used');
			//bd($source, 'source used');
			$f->attr([
				'hx-get' => $adminEdit, // send get to InputfieldMeasurement - caught by HTMX AJAX LISTENER above
				'hx-target' => "[name={$target}]", // our element to target with swap
				'hx-swap' => 'outerHTML', // we'll swap the innerHTML (this is the default but it has never worked for me if not specified)
				'hx-trigger' => 'change',
				'hx-include' => "[name={$source}]"
			]);
			if($field->enable_conversion != 1) {  // 'Ask' or unassigned option
				$f->attr('hx-confirm', $this->_("Convert measurement to selected units? (Null selection deletes magnitude)"));
			}
			//prevent selectize from hijacking the 'change' event (if SelectizeAll installed)
			$f->addClass('no-selectize');
			########## end of hx- attributes ########################
		}
		$inputfields->add($f);

		
		//remark
		if ($field->show_remark) {
			//bd($value->get('remark'), 'get remark');
			$f = $this->modules->get('InputfieldTextArea');
			$f->attr('name', "{$name}_remark");
			$f->attr('value', $value->get('remark'));
			$f->label = __('Remark');
			$f->notes = __("Default rendering is as a tooltip");
			$f->columnWidth = 100;
			$f->collapsed = Inputfield::collapsedBlank;
			$f->rows = 1;
			$inputfields->add($f);
		}
		return $inputfields->render();
	}

	/**
	 * Convert the old selected unit to the new one
	 * Called by HTMX get
	 *
	 * @param $target
	 * @param $value
	 * @param $newUnit
	 * @return array|string|string[]|null
	 * @throws MeasurementException
	 */
	private function htmxConvert($target, $value, $newUnit) {
		/* @var Measurement $value */
		if($newUnit) {
			$magnitude = $value->valueAs($newUnit);
		} else {
			$magnitude = '';
		}
		//bd($target, 'target before replace');
		$re = '/value\=\".*\"/mU';
		$target =  preg_replace($re, 'value="' . $magnitude . '"', $target);
		//bd($target, 'target after replace');
		return $target;
	}

	/**
	 * Value to render if the inputfield is not editable (e.g. locked)
	 *
	 * @return string
	 */
	public function renderValue(): string {
		$value = $this->attr('value');
		return ($value) ? $value->render() : '';
	}

	/**
     * This Inputfield is defined empty, if the magnitude field is not populated
     *
     * Used by the 'required' check to see if the field is populated.
     * Overwrites parent function Inputfield::isEmpty()
     *
     * @return bool
     *
     */
    public function isEmpty() {
        $value = $this->attr('value');
		if(!$value || !$value->magnitude) return true;
		if(is_array($value->magnitude)) $value->magnitude = implode('|', $value->magnitude);
        if(is_object($value) && !strlen("{$value->magnitude}")) return true;
        return false; 
    }

    /**
     * Process the input from the given WireInputData (usually $input->get or $input->post), load and clean the value for use in this Inputfield.
     *
     * @param WireInputData $input
	 * @return $this
	 *
	 */
	public function ___processInput(WireInputData $input) {
		try {
			$name = $this->attr('name');
			$value = $this->attr('value');
			if(!is_a($value, 'MetaTunes\MeasurementClasses\Measurement')) return $this;
			/* @var $value Measurement */
			$old = clone $value; // Don't want $old to change when $value is altered
			//bd($value, 'value at start of process input');
			// $value->targetSanitized = null;

			$input_names = array(
				'magnitude' => "{$name}_magnitude",
				'unit' => "{$name}_unit",
				'quantity' => "{$name}_quantity",
				'update' => "{$name}_update",
				'remark' => "{$name}_remark"
			);

			$value->set('magnitude', [0]); // default to prevent errors if no input
			// loop inputs and set them (  even if not changed - as magnitude format may be wrong)
			foreach($input_names as $key => $name) {
				//bd(['input' => $input->$name, 'value->key' => $value->get($key)], 'input name etc');
				if(isset($input->$name)) {  // deleted  && $value->get($key) != $input->$name from condition
					//bd($key, 'key');
					if($key == 'magnitude') {
						$input->$name = trim($input->$name);
						if(!$input->$name) $input->$name = 0;
						/*
						 * Set the regex for the required pattern for the magnitude field
						 */
						//The relevant unit to use for formatting depends on whether we are updating...
						//bd($input[$input_names['update']], 'input names - update');
						if($input[$input_names['update']]) {
							$unit = $value->get('unit');
							$update = true;
						} else {
							$update = false;
							$unit = $input[$input_names['unit']];
						}
						// Now we know how many elements there should be to be separated by pipes
						$unitArray = explode('|', $unit);
						$unitCount = count($unitArray);
						// Set the pattern...
						$decimalPattern = "[+-]?([0-9]+\.?[0-9]*|\.[0-9]+)([eE][+-]?[0-9]+)?";  // matches scientific notation as well as decimal
						$re = '/^';
						for($i = 0; $i < $unitCount; $i++) {
							if($i > 0) $re .= '\|';
							$re .= $decimalPattern;
						}
						$re .= '$/';
						// ... and check the pattern
						$msg = $this->_("Change not made - magnitude not in correct format.");
						$msg .= "\n";
						$msg .= ($update) ? $this->_("When converting measurements, leave the magnitude in the correct format for the previous units.") :
							$this->_("Did you mean to convert the value? If so, tick the 'convert' box.");
						if(!preg_match($re, $input->$name)) throw new MeasurementException($msg);
						// If OK, carry on!
						//bd([$key, $input->$name], '$input->$name');
						if(!is_numeric($input->$name)) {
//							$magnitude = explode('|', $input->$name);
//							$magnitude = array_filter($magnitude, 'is_numeric');
							$magnitude = $this->sanitizer->magnitude($input->$name);  //added by hook in FieldtypeMeasurement
							$value->set($key, $magnitude);
						} else {
							$value->set($key, [$input->$name]);
						}
						//bd($value->get('magnitude'), 'Magnitude0');
					} else {
						$value->set($key, $input->$name);
					}
//					$this->trackChange('value');
					//bd($this->getChanges());
					//bd($value->get('magnitude'), 'Magnitude1');
				}
			}

			$new = $value;
			//bd(['old' => $old, 'new' => $new], 'changes to field');
			$oldUnit = $old->get('unit');
			$newUnit = $new->get('unit');
//			bd(['old unit' => $oldUnit, 'new unit' => $newUnit], 'change of unit?');
//			bd($value->get('update'), 'update?');
			if($oldUnit and $newUnit and $oldUnit != $newUnit and $value->get('update') == 1) {
				//bd(['old unit' => $oldUnit, 'new unit' => $newUnit], 'change of unit');
				// Check consistency of units and magnitude
				//bd(['Mag' => count($value->get('magnitude')), 'Unit' => count((explode('|', $oldUnit)))], 'count compare old');
				if(count($value->get('magnitude')) != count((explode('|', $oldUnit)))) {
					// In theory, this should never happen as the input has already been checked
					throw new MeasurementException(sprintf($this->_('Magnitude (%1$s) not consistent with original unit (%2$s)'), $value->get('magnitude'), $oldUnit));
				}
				$value->set('unit', $oldUnit);
				$value->convertTo($newUnit);
			} else {
				//bd('No change');
				if($value->get('unit')) {
					// Check consistency of units and magnitude
					//bd(['Mag' => count($value->get('magnitude')), 'Unit' => count((explode('|', $newUnit)))], 'count compare new');
					if(count($value->get('magnitude')) != count((explode('|', $newUnit)))) {
						// In theory, this should never happen as the input has already been checked
						throw new MeasurementException(sprintf($this->_('Magnitude (%1$s) not consistent with chosen unit (%2$s)'), $value->get('magnitude'), $newUnit));
					}
				}
			}
			//bd($value, 'value at end of process_input');
			//bd($this, 'this at end of process_input');



		} catch(MeasurementException $e) {
			$this->error($e->getMessage());
		}
		return $this;
    }

	public function ___getConfigInputfields() {
		$inputfields = parent::___getConfigInputfields();
// No separate input settings at the moment - all in the details tab
		return $inputfields;
	}

	public function ___getConfigAllowContext($field) {
		$a = array(); // placeholder - no changes at present
		return array_merge(parent::___getConfigAllowContext($field), $a);
	}

}
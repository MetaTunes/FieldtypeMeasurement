<?php namespace ProcessWire;

/**
 * ProcessWire Measurement Fieldtype
 *
 * Field that stores 3 values for: quantity (Temperature, Mass etc.), unit (Celsius, kilogram etc.) and value (in the specified units).
 * Define quantity and unit options field settings.
 *
 * @author Mark Evens
 * @license Licensed under GNU/GPL v3
 * @link https://processwire.com/talk/topic/26241-fieldtypemeasurement/
 *
 * ProcessWire 2.x, 3.x
 * Copyright (C) 2016 by Ryan Cramer
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 *
 * http://processwire.com
 *
 * @version 0.0.6
 * @since 0.0.5 minor fixes and new Measurement methods
 * @since 0.0.4 allowed specific formats in config file, additional units, dimensional analysis supported
 * @since 0.0.3 added static function addMeasurement(), altered add() and subtract() methods to Measurement, bug fixes
 * @since 0.0.2 revised db schema to hold base unit value
 * @since 0.0.1 minor mods
 * @since 0.0.0 initial version
 *
 *
 *
 *  * MODULE CONFIGURATION PROPERTIES
 * ===============================
 * @property string $quantity The physical quantity to be measured
 * @property string $units The units to be presented as options
 *
 *  * ERROR STRINGS
 * @property string $invalidUnits
 *
 */

class FieldtypeMeasurement extends Fieldtype {


	/**
	 * Construct the Fieldtype and populate default settings and column types
	 *
	 */
	public function __construct() {
		parent::__construct();
		require_once(wire('config')->paths->siteModules . basename(__DIR__) . '/Measurement.php');
		require_once(wire('config')->paths->siteModules . basename(__DIR__) . '/MeasurementDimension.php');
	}

	public static function getModuleInfo() {
		return array(
			'title' => __('Measurement', __FILE__), // Module Title
			'summary' => __('Field that stores 3 values for: quantity (Temperature, Mass etc.), unit (Celsius, kilogram etc.) and magnitude (in the specified units).', __FILE__), // Module Summary
			'version' => '0.0.5',
            'author' => 'Mark Evens',
			'requires' => ['ProcessWire>=3.0.148'],
            'installs' => 'InputfieldMeasurement',
        );
    }

	/**
	 * Initialize this Fieldtype
	 *
	 */
	public function init() {
		$this->invalidUnits = __('This unit is not valid for the quantity type of this field. Resetting value to zero.');
		parent::init();
	}

	/**
	 * Format value for output
	 *
	 * @see Measurement.php
	 */
	public function ___formatValue(Page $page, Field $field, $value) {
		if(!$value instanceof Measurement) return null;
		return $value->render();
	}

	/**
	 * Return the Inputfield for this fieldtype
	 *
	 * @param Page $page
	 * @param Field $field
	 * @return Inputfield
	 *
	 * @throws WireException
	 */
	public function getInputfield(Page $page, Field $field) {
		$inputfield = $this->wire('modules')->get('InputfieldMeasurement');
		$inputfield->setField($field);
		return $inputfield;
	}

	/**
	 * nothing compatible?
	 *
	 * @throws WireException
	 */
	public function ___getCompatibleFieldtypes(Field $field) {
		$fieldtypes = $this->wire(new Fieldtypes());
		foreach($this->wire('fieldtypes') as $fieldtype) {
			if($fieldtype instanceof self) {
				$fieldtypes->add($fieldtype);
			}
		}
		return $fieldtypes;
	}

	/**
	 * Given a raw value (value as stored in DB), return the value as it would appear in a Page object
	 *
	 * @param Page $page
	 * @param Field $field
	 * @param string|int|array $value
	 * @return string|int|array|object $value
	 *
	 * @throws WireException
	 */
	public function ___wakeupValue(Page $page, Field $field, $value) {

		// if for some reason we already get a valid value, then just return it
		if($value instanceof Measurement) return $value;
		//bd($value, 'wakeup value');
		// start a blank value to be populated
		$measurement = $this->getBlankValue($page, $field);

		// if we were given a blank value, then we've got nothing to do: just return a blank Measurement object
		if(empty($value) || !is_array($value)) return $measurement;

		// create new Measurement object
		//bd($measurement, 'measurement0 in ___wakeupValue');
//bd($value['data'], 'data in wakeupvalue');
		$measurement->quantity = $value['quantity'];
		if(!in_array($measurement->quantity, Measurement::getQuantities())) {
			$this->error(sprintf($this->_(
				'Quantity (%s) in database has no Config file'),
				$measurement->quantity));
			return $measurement;
		}
		$measurement->baseMagnitude = $value['data'];
		$measurement->dimension = Measurement::getDimension($measurement->quantity);
		if($value['unit']) {
			$measurement->unit = $value['unit'];
			$units = Measurement::getUnits($measurement->quantity);
			//bd($units);
			if(array_key_exists($value['unit'], $units) && isset($value['magnitude'])) {
				$measurement->magnitude = explode('|', $value['magnitude']); // $measurement->valueFromBase($value['data'], $value['unit']);
			} else {
				$measurement->magnitude = $measurement->baseMagnitude;
				$measurement->unit = Measurement::getBaseUnit($measurement->quantity);
				$this->error(sprintf($this->_(
					'The previously saved unit (%1$s) is not (or no longer) compatible with this quantity (%2$s). Perhaps a changed config file? Value is shown as base units.'),
					$value['unit'], $measurement->quantity) . ($this->_("\nThe best way to fix this may be to save the base unit value shown and then convert to the required unit.")));
			}
		} else {
			$measurement->unit = Measurement::getBaseUnit($measurement->quantity);
			$measurement->magnitude = $measurement->baseMagnitude;
			$this->error($this->_(
				'Unit is not known. Value is shown as base units. Please amend as appropriate.'));
		}
		if(!is_array($measurement->magnitude)) $measurement->magnitude = [$measurement->magnitude];

		//bd($measurement, 'measurement1 in ___wakeupValue');
		// get the current shortLabel and plural from the config file - not a saved version
		if($measurement->unit and $measurement->quantity) {
			$units = Measurement::getUnits($measurement->quantity);

				foreach($units[$measurement->unit] as $key => $item) {
					if($key == 'conversion') continue;
					if(isset($units[$measurement->unit][$key])) {
						$measurement->set($key, $item);
					} else {
						if($measurement->get($key)) $measurement->remove($key);
					}

				}

			if($this->unit and !is_null($this->magnitude)) {
				$this->convertFrom($this->magnitude, $this->unit);
			}

		}
		// $measurement->resetTrackChanges();
		//bd($measurement, 'measurement2 in ___wakeupValue');
		return $measurement;
	}

	/**
	 * Return a blank ready-to-populate version of a field of this type
	 *
	 * @return object
	 *
	 */
	public function getBlankValue(Page $page, Field $field) {
		$measurement = new Measurement($field->quantity, null, []);
		//bd($measurement, 'new measurement in getBlankValue');
		//bd($field, 'field in getBlankValue');
		//bd($field->quantity, 'quantity in getBlankValue');
		if ($field->quantity) $measurement->set('quantity', $field->quantity);
		//ToDo - check that it is OK to delete the following
//		if ($field->units) $measurement->set('units', $field->units);
		$measurement->set('magnitude', []);
		$measurement->set('shortLabel', null);
		$measurement->set('plural', null);
		$measurement->setTrackChanges(true);
		//bd($measurement, 'measurement returned from getBlankValue');
		return $measurement;
	}

	/**
	 * Given an 'awake' value, as set by wakeupValue, convert the value back to a basic type for storage in DB.
	 *
	 * @param Page $page
	 * @param Field $field
	 * @return array
	 *
	 */
	public function ___sleepValue(Page $page, Field $field, $value) {

		$sleepValue = array();
//bd($value, 'value in sleep');
		// if we are given something other than a Measurement object,
		// then just return a blank array
		if(!$value instanceof Measurement) return $sleepValue;

		//bd($value);
		if($value->get('unit')) {
			// Use up-to-date conversion to save base magnitude, if we have a unit
			//bd($value->valueAsBase());
			$data = (is_array($value->valueAsBase()) ? $value->valueAsBase()[0] : $value->valueAsBase());
		} else if($value->get('baseMagnitude')) {
			$data = $value->get('baseMagnitude');
		} else {
			$data = 0;
		}
		//bd($data, 'data in ___sleepValue');
		$magnitude = (is_array($value->get('magnitude'))) ? implode('|', $value->get('magnitude')) : $value->get('magnitude');
		$sleepValue = array(
			'data' => $data,
			'magnitude' => $magnitude,
			'unit' => $value->get('unit'),
			'quantity' => $value->get('quantity')
		);
//bd($sleepValue, 'sleepValue');
		return $sleepValue;
	}

	/**
	 * Given a value, make it clean for storage within a Page
	 *
	 * @throws WireException
	 */
	public function sanitizeValue(Page $page, Field $field, $value) {

		// if given a blank value, return a valid blank value
		if(empty($value)) return $this->getBlankValue($page, $field, $value);

		// if given something other than a Measurement object, throw an error
		if(!$value instanceof Measurement) {
			throw new WireException(sprintf($this->_('Value set to field %s must be a Measurement object'), $field->name));
		}

		// note that sanitization of individual fields within a given event is already
		// performed by the Measurement::set() method, so we don't need to do anything else here.

		return $value;
	}

	/**
	 * Return the database schema that defines a Measurement
	 *
	 */
	public function getDatabaseSchema(Field $field) {

		$schema = parent::getDatabaseSchema($field);

		$schema['data'] = 'double NOT NULL';  // value in base units
		$schema['magnitude'] = 'varchar(64)'; // value in current units - needs to be text to store composite values
		$schema['unit'] = 'text NOT NULL';
		$schema['quantity'] = 'text NOT NULL';


		return $schema;
	}

	/**
	 * Method called when the field is database-queried from a selector
	 *
	 * @throws WireException
	 */
	public function getMatchQuery($query, $table, $subfield, $operator, $value) {
		// If searching 'magnitude' then assume our default (data) field
		if($subfield == 'baseMagnitude') $subfield = 'data';
		return parent::getMatchQuery($query, $table, $subfield, $operator, $value);
	}


	/**
	 * Get any inputfields used for configuration of this Fieldtype.
	 *
	 * This is in addition any configuration fields supplied by the parent Inputfield.
	 *
	 * @param Field $field
	 * @return InputfieldWrapper
	 *
	 * @throws WirePermissionException
	 */
	public function ___getConfigInputfields(Field $field) {

		$inputfields = parent::___getConfigInputfields($field);

		$f = $this->modules->get("InputfieldSelect");
		$quantities = Measurement::getQuantities();
		$f->label = __("Quantity");
		$f_name = 'quantity';
		$f->name = $f_name;
		$f->columnWidth = 50;
		$f->description = __("Type of physical quantity to be measured.");
		$f->notes = __("Save after changing to see the options for units applicable to this quantity.");
		foreach($quantities as $quantity) {
			$f->addOption($quantity);
		}
		$f->value = $field->get('quantity');
		$inputfields->append($f);

		$f = $this->modules->get('InputfieldCheckbox');
		$f->attr('name', 'hide_quantity');
		$f->label = __('Hide quantity display in the input field.');
		$f->attr('checked', $field->hide_quantity ? 'checked' : '' );
		$f->columnWidth = 50;
		$inputfields->append($f);

		$quantity = $field->get('quantity');
		$units = ($quantity) ? Measurement::getUnits($quantity) : [];
		if($quantity) {

			$notes = '<p>' . Measurement::getQuantityNotes($quantity) . '</p>';
			foreach($units as $key => $unit) {
				//bd($unit);
				$extraNotes = isset($unit['notes']) ? "<h4>{$key}</h4><p>{$unit['notes']}</p>" : null;
				$notes .= $extraNotes;
			}

			if($notes) {
				$f = $this->modules->get('InputfieldMarkup');
				$f->attr('name', 'notes');
				$f->label = __("Notes about $quantity");
				$f->value = $notes;
				$f->collapsed = Inputfield::collapsedYes;
				$inputfields->append($f);
			}

			$f = $this->modules->get('InputfieldAsmSelect');
			$f_name = 'units';
			$f->name = $f_name;
			$f->label = __('Select the units you want to appear as options for this field.');
			$f->columnWidth = 50;
			$quantity = $field->get('quantity');
			foreach($units as $key => $unit) {
				$shortLabel = $unit['shortLabel'];
				if($shortLabel) $shortLabel = "($shortLabel)";
				$alias = (isset($unit['alias']) && $unit['alias']) ? $unit['alias'] : $key;
				$f->addOption($key, "$alias $shortLabel");
			}
			$f->value = $field->get('units');
			$inputfields->append($f);

			$f = $this->modules->get('InputfieldCheckbox');
			$f->attr('name', 'show_update');
			$f->label = __('Show an update checkbox');
			$f->notes = __("If the update box in the input field is checked, any changes to the units will automatically convert the magnitude.");
			$f->attr('checked', $field->show_update ? 'checked' : '');
			$f->columnWidth = 50;
			$inputfields->append($f);
		}

		return $inputfields;
	}


}